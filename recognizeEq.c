/* recognizeExp.c, Gerard Renardel, 29 January 2014
 *
 * In this file a recognizer acceptExpression is definined that can recognize
 * arithmetical expressions generated by the following BNF grammar:
 *
 * <expression>  ::= <term> { '+'  <term> | '-' <term> }
 *
 * <term>       ::= <factor> { '*' <factor> | '/' <factor> }
 *
 * <factor>     ::= <number> | <identifier> | '(' <expression> ')'
 *
 * Input for the recognizer is the token list constructed by the scanner (in scanner.c).
 * For the recognition of a token list the method of *recursive descent* is used.
 * It relies on the use of three functions for the recognition and processing of
 * terms, factors and expressions, respectively.
 * These three functions are defined with mutual recursion, corresponding with the
 * structure of the BNF grammar.
 */

#include <stdio.h>  /* getchar, printf */
#include <stdlib.h> /* NULL */
#include "scanner.h"
#include "recognizeEq.h"
#include <string.h>

/* The functions acceptNumber, acceptIdentifier and acceptCharacter have as
 * (first) argument a pointer to an token list; moreover acceptCharacter has as
 * second argument a character. They check whether the first token
 * in the list is a number, an identifier or the given character, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */

int acceptNumber(List *lp) {
  if (*lp != NULL && (*lp)->tt == Number) {
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

int acceptIdentifier(List *lp) {
  if (*lp != NULL && (*lp)->tt == Identifier) {
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

int acceptCharacter(List *lp, char c) {
  if (*lp != NULL && (*lp)->tt == Symbol && ((*lp)->t).symbol == c) {
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

/* The functions acceptFactor, acceptTerm and acceptExpression have as
 * argument a pointer to a token list. They check whether the token list
 * has an initial segment that can be recognized as factor, term or expression, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */

int acceptFactor(List *lp) {
  return
    (  acceptNumber(lp)
    || acceptIdentifier(lp)
    || ( acceptCharacter(lp,'(')
       && acceptExpression(lp)
       && acceptCharacter(lp,')')
      )
    );
}


int acceptTerm(List *lp) {
    if(!acceptNumber(lp) || !acceptIdentifier(lp)) {
        return 0;
    }
    while (acceptNumber(lp) || !acceptIdentifier(lp)){
        if(acceptCharacter(lp, '^')) {
            if (!acceptNumber(lp)) {
                return 0;
            }
        }
    }
    return 1;
}


int acceptExpression(List *lp) {
  if(acceptCharacter(lp, '-')){
      printf("- gespot \n");
    if(!acceptTerm(lp)){
        return 0;
    }
  } else {
      if (!acceptTerm(lp)) {
          return 0;
      }
  }
  while (acceptCharacter(lp, '+') || acceptCharacter(lp, '-')) {
    if (!acceptTerm(lp)) {
      return 0;
    }
  } /* no + or -, so we reached the end of the expression */
  return 1;
}


int acceptEquation(List *lp){
    if (acceptExpression(lp) && acceptCharacter(lp, '=') && acceptExpression(lp)){
        return 1;
    } else {
        return 0;
    }
}

int countVar(List *lp){
    List cp = *lp;
    int count = 0;
    List tp = NULL;
    while (cp != NULL) {
        if ((cp)->tt == Identifier){
            if(tp == NULL){
                tp = cp;
                count = 1;
            } else {
                if (strcmp(cp->t.identifier, tp->t.identifier) == 0){
                    return 2;
                }
            }
        }
        cp = (cp)->next;
    }
    return count;
}
int findDegree(List *lp){
    List cp = *lp;
    int dMax = 0;
    while (cp != NULL) {
        if((((cp)->t).symbol == '^') && ((cp)->tt == Symbol)){
            if ((((cp)->next)->t.number) > dMax) {
                dMax = ((cp)->next)->t.number;
            }
        }
        cp = (cp)->next;
    }
    return dMax;
}

/* The function recognizeExpressions demonstrates the recognizer. */
void recognizeEquation(void) {
  char *ar;
  List tl, tl1;
  ar = readInput();
  int d = 0;
  while (ar[0] != '!') {
    tl = tokenList(ar);
    printf("give an equation: ");
    printList(tl);
    tl1 = tl;
    if (acceptEquation(&tl1) && tl1 == NULL) {
      printf("this is an equation");
        if(countVar(&tl1) != 1){
            printf(", but not in 1 variable.\n");
        }else{
            printf("in 1 variable");
            d = findDegree(&tl1);
            if(d != 0){
                printf(" of degree %d.\n", d);
            } else {
                printf("\n");
            }
        }
    }else {
      printf("this is not an equation\n");
    }
    printf("\n");
    free(ar);
    freeTokenList(tl);
    ar = readInput();
  }
  free(ar);
  printf("good bye\n\n");
}
